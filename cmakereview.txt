cmake使用上过于灵活，所以需要固定一种方式使用，而不是让别人疑惑
context
1. cmake
2. kconfig - generate-time
3. dts - generate-time
4. generate file, xml, header file, cmake file(kconfig) self
5. execute shell script
6. uboot/atf .etc

这里先定义cmake整体框架，而不是过多关注生成产物

其次，定义基础设施，包括引导代码和常用库的正常编译和运行

最后，定义神经元
之所以成为神经元，是因为该内核可以放在任意一级作为管理器，
包括：
Kernel - 
		secure - el0(定义在更抽象的层上，泛核)/el1/el2/el3
		non-secure - el0/el1/el2/el3
		real - el0/el1/el2/el3
在任意层上，都可以使用某个神经元来执行管理器的功能
el3可能并不需要神经元，因为这跟厂商定义的BL1/BL31冲突
但是如果是纯裸机，不含bootloader的话，也有可能直接使用神经元

并且，可以复用相同的代码以减少存储，但不代表只要一份神经元，而是多份神经元的副本
所以，两个问题
1. setup env, 当环境未建立时需要初始化每一级的环境，包括全局和临时寄存器
2. save/restore env，当环境建立后，全局寄存器可以不必更改，只需要对临时寄存器只需保存和恢复即可
所以，务必使用最简洁的方式实现，其他都以库的形式作为可配置

将神经元应用在某个SOC上时，可以使层级分立、金字塔式的镜像配置，例如el3 - atf, el2 - 
hypervisor, el1 - linux, el0 - app，变成扁平化的网状配置，例如一个neuro-base -> neuro-lib0 -> neuro-libx
相当于一个neuro+多个特异化的分身就可以完成基本的SOC管理工作

使用最纯粹的代码，不要执着于细节，后面再增加一定的细节

stack include:
// el3
monitor

// el1
superviser

// el2
hypervisor

// el0
administrator

突出观点
1. 逻辑核（上下文环境切换）与物理核（环境初始化）
2. 执行实体与入口点，入口点以handler称谓，例如异常handler是内核执行实体的入口点，
start是各个镜像（一般镜像以用户线程或内核的形式存在）自身的入口点，
每一个入口点都需要设置或保存恢复环境或上下文。
还有很多其他的handler，例如signal（用户）/thread/process（用户和内核） handler
是每个线程的入口点，以及exp/irq handler是内核的入口点
3. 栈和上下文区，对于每一个用户线程而言，必须有用户栈和上下文区，因为用户函数需要栈，
用户会陷入内核或是切换到其他用户线程，所以需要上下文区保存和恢复上下文；
当陷入内核执行内核函数时，必须需要内核栈，因为内核允许并发时，
同一个内核函数需要同时被多个用户线程访问；同时也需要上下文区，
因为在执行内核函数时，可能会切换到其他用户线程或是异常handler。
对于内核线程来说，需要内核栈和上下文区。对于内核其他句柄来说，
包括中断和异常句柄，需要共用内核配置好（包括内核初始化的流程）
的percpu栈，至于是否需要上下文区待定，因为根据pcs，在函数嵌套调用时
也会保存一部分环境，说白了每一个handler都需要栈。
所以，设置上下文区的条件是执行实体的切换。
例如，从用户线程和用户线程切换，需要被切换方用户线程保存上下文；
用户线程切换内核（内核线程或内核异常），需要用户线程保存上下文；
内核线程切换用户线程，需要内核线程保存上下文；内核同步异常切换用户线程，
需要用户内核上下文区保存上下文；内核异步异常切换用户，一定是执行完成，
不可中途打断，所以不需上下文区；内核线程或切换内核线程，需要被切换方内核线程保存上下文；
内核同步异常（优先级低）切换异常（优先级高），需要用户内核上下文区保存上下文；
内核异步异常（优先级低，中断）切换异步异常（优先级高）一定不会是内核同步异常，
属于嵌套调用，不需要上下文区，保证栈足够即可，因为顶层执行实体不需要上下文区，
因为它们不会切走；但实际上内核异步异常发生后，是不能嵌套调用，非常容易无限循环调用，因为出现的
异常在没有解决时，会一直异步进入该异常，所以一旦可以返回，就会出现死循环

- 可重入：该handler可以在任意时刻被打断，后面会从这个打断点恢复，很明显具备上下文的handler是可重入的
- 不可重入：该handler不能被打断，必须从头执行到尾，或是只能执行一次，不能返回（内核异步异常）

4. handler的可迁移性，指的是一个用户线程handler是否可以在另一个用户线程handler使用，
首先需要对该handler所在的代码段可访问，为该handler分配新的栈不是必要的，因为栈桢是链式的，
可以追溯到的，该handler执行的上下文为当前线程所有，
唯一的问题是该handler以及所依赖的所有handler的代码段均可以被另一个线程可访问。
所以，如果内核是被所有用户线程可访问，那么完全将一部分内核管理函数放置在用户态，
且将这部分函数作为共享库，被多个用户共享使用，这样降低了内核故障的风险，并将其转移到用户态。
回到原本的问题，一个用户线程handler与另一个线程handler互访问，答案是可以的，
只要这部分代码作为共享库，私有的handler是不可以的
5. 上下文的设置还需要看该handler的生命周期，如果该handler从头执行到尾，中间不会被打断，
这种是不需要上下文的。只有那种可能被打断的handler才需要上下文来恢复上次被打断的位置。
还有上下文和栈的区别就是组合和嵌套式handler的区别。上下文设置为了组合调用，栈是为了嵌套调用，
所以各式的切换必须以上下文的方式来保存和恢复，而中断或异常嵌套调用仅用栈就可以保存和恢复


神经元”粘性或高伸缩性“的原因在于，对上提供一个资源视图，其他用户接口标准（例如POSIX）都需要与资源视图进行适配，
从而只要更新适配层，就可以为多种用户接口标准服务。
而为了提供资源视图，需要对下提供更泛的资源概念，以及更泛的process概念，甚至用户可以自定义process，而放弃很有重量的thread/process，
并且自定义的Process可以参与整个系统的Process调度上，这样在用户层也可以实现更泛的OS概念；
这种更泛的process可以将内核层提供的各类接口（系统调用）”黏住“，从而在内核层之上提供一层抽象层，作为用户态OS
更泛的Process也可以兼容各类(linux/hypervisor/monitor)OS功能以及各类硬件实现(arm/riscv)

